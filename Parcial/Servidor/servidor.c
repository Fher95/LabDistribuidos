/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdlib.h>
#include <string.h>
#include "gestionHamburguesas.h"
int idClientes=1;
proxNodoHamburguesa cabeza = NULL, sigHamburguesa;
proxNodoHamburguesa nuevaHamburguesa;

int *
getidentificador_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;	
	result=idClientes;
	idClientes++;
	return &result;
}

nodo_datos_empresa *
consultardatosempresa_1_svc(void *argp, struct svc_req *rqstp)
{
	static nodo_datos_empresa  result;

	FILE *archivo;
	char lineaLeida[100];
	archivo = fopen("datosEmpresa.txt","r");
	printf("\n Ejecutando Consulta de Precios. \n");
	if (archivo == NULL)
	{
		printf("Erro al abrir el archivo");
	} 		
	else
	{
			fgets(lineaLeida,100,archivo);
			strcpy(result.nombre,lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.nit = atoi(lineaLeida);				
	}

	return &result;
}

nodo_costos_hamburguesa obtenerCostos(){

	nodo_costos_hamburguesa  result;
	FILE *archivo;
	char lineaLeida[100];
	archivo = fopen("costoshamburguesa.txt","r");
	printf("\n Ejecutando Consulta de Precios. \n");
	if (archivo == NULL)
	{
		printf("Erro al abrir el archivo");
	} 		
	else
	{
			fgets(lineaLeida,100,archivo);


			result.costoHamburguesaPequenia = atof(lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.costoHamburguesaMediana = atof(lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.costoHamburguesaGrande = atof(lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.costoIngredientesExtra = atof(lineaLeida);
	
	}

	return result;
}

nodo_costos_hamburguesa *
consultarcostoshamburguesa_1_svc(void *argp, struct svc_req *rqstp)
{
	static nodo_costos_hamburguesa  result;

	FILE *archivo;
	char lineaLeida[100];
	archivo = fopen("costoshamburguesa.txt","r");
	printf("\n Ejecutando Consulta de Precios. \n");
	if (archivo == NULL)
	{
		printf("Erro al abrir el archivo");
	} 		
	else
	{
			fgets(lineaLeida,100,archivo);


			result.costoHamburguesaPequenia = atof(lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.costoHamburguesaMediana = atof(lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.costoHamburguesaGrande = atof(lineaLeida);
			fgets(lineaLeida,100,archivo);
			result.costoIngredientesExtra = atof(lineaLeida);
	
	}

	return &result;	
}

float calcularCostoHamburguesa(char *tipo, int cantIngredientes){
	float result = 0;
	float valor=0;
	nodo_costos_hamburguesa costos = obtenerCostos();
	if (strcmp(tipo,"Pequenia")==0){
		valor = costos.costoHamburguesaPequenia;		
	}
	if (strcmp(tipo,"Mediana")==0){
		valor = costos.costoHamburguesaMediana;		
	}
	if (strcmp(tipo,"Grande")==0){
		valor = costos.costoHamburguesaGrande;		
	}
	float valExtra = costos.costoIngredientesExtra*cantIngredientes;
	result = valor+valExtra;
	return result;
}

bool_t *
comprarhamburguesasistema_1_svc(nodo_hamburguesa_factura *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("\n Ejecutando Compra de Hamburguesas. \n");
	printf("	Nombre: %s \n", (*argp).nombre);
	printf("	Cantidad Ingredientes: %d \n", (*argp).cantidadIngredientesExtra);
	printf("	Tipo: %s \n", (*argp).tipo);

	nuevaHamburguesa = (proxNodoHamburguesa) malloc (sizeof (nodo_hamburguesa_factura) );
	
	strcpy(nuevaHamburguesa->nombre,(*argp).nombre);
	nuevaHamburguesa->cantidadIngredientesExtra = (*argp).cantidadIngredientesExtra;
	strcpy(nuevaHamburguesa->tipo,(*argp).tipo);
	nuevaHamburguesa->costo = calcularCostoHamburguesa(nuevaHamburguesa->tipo,nuevaHamburguesa->cantidadIngredientesExtra);

	if (cabeza==NULL)
	{
		cabeza = nuevaHamburguesa;
		sigHamburguesa = cabeza;
	}
	else
	{
		sigHamburguesa->nodoSiguiente = nuevaHamburguesa;
		sigHamburguesa=nuevaHamburguesa;
	}
	sigHamburguesa->nodoSiguiente=NULL;
	result=TRUE;

	return &result;
}

bool_t *
modificarcompra_1_svc(nodo_datos_hamburguesa_modificada *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	char *varNom = (*argp).nombreAntiguo;
	proxNodoHamburguesa *hamburguesaActual;
	hamburguesaActual=&cabeza;
	result = FALSE;
	while (*(hamburguesaActual)!=NULL){
		if (strcmp((*hamburguesaActual)->nombre,varNom)==0){
			strcpy((*hamburguesaActual)->nombre,(*argp).varHamburguesa.nombre);
			(*hamburguesaActual)->cantidadIngredientesExtra = (*argp).varHamburguesa.cantidadIngredientesExtra;
			strcpy((*hamburguesaActual)->tipo,(*argp).varHamburguesa.tipo);
			result = TRUE;	
			break;			
		}
		else {
			(*hamburguesaActual)=(*hamburguesaActual)->nodoSiguiente;
		}	
	}

	return &result;
}

bool_t *
eliminarahamburguesa_1_svc(char **argp, struct svc_req *rqstp)
{
	static bool_t  result;
	proxNodoHamburguesa *hamburguesaActual;
	//Si el resultado es falso es porque seguramente no encontrÃ³ la hamburguesa (?)
	result=FALSE;
	if (strcmp(cabeza->nombre,*argp)==0){
		cabeza = cabeza->nodoSiguiente;
	}
	else {
		hamburguesaActual=&cabeza;
		while ((*hamburguesaActual)->nodoSiguiente != NULL){
			if (strcmp((*hamburguesaActual)->nodoSiguiente->nombre,*argp)==0){
				
				(*hamburguesaActual)->nodoSiguiente = (*hamburguesaActual)->nodoSiguiente->nodoSiguiente;
			
				result = TRUE;	
				break;			
			}
			else {
				(*hamburguesaActual)=(*hamburguesaActual)->nodoSiguiente;
			}	
		}
	}

	return &result;
}


proxNodoHamburguesa listarHamburguesasCliente(int parId){

	proxNodoHamburguesa nuevaCabeza = NULL, varSigHamburguesa;

	proxNodoHamburguesa hamburguesaNueva;
	proxNodoHamburguesa *hamburguesaActual;
	hamburguesaActual=&cabeza;

	while (*(hamburguesaActual)!=NULL){
		if ((*hamburguesaActual)->idCliente==parId){

			hamburguesaNueva = (proxNodoHamburguesa) malloc (sizeof (nodo_hamburguesa_factura) );	
			strcpy(hamburguesaNueva->nombre,(*hamburguesaActual)->nombre);
			hamburguesaNueva->cantidadIngredientesExtra = (*hamburguesaActual)->cantidadIngredientesExtra;
			strcpy(hamburguesaNueva->tipo,(*hamburguesaActual)->tipo);
			hamburguesaNueva->costo = (*hamburguesaActual)->costo;
			hamburguesaNueva->idCliente = (*hamburguesaActual)->idCliente;
			if (nuevaCabeza==NULL)
			{
				nuevaCabeza = hamburguesaNueva;
				varSigHamburguesa = nuevaCabeza;
			}
			else
			{
				varSigHamburguesa->nodoSiguiente = hamburguesaNueva;
				varSigHamburguesa=hamburguesaNueva;
			}
			sigHamburguesa->nodoSiguiente=NULL;
		
		}
		(*hamburguesaActual)=(*hamburguesaActual)->nodoSiguiente;		
	}
	return nuevaCabeza;
	
}



nodo_factura *
mostrarfactura_1_svc(void *argp, struct svc_req *rqstp)
{
	static nodo_factura  result;

		

	return &result;
}

bool_t *
pagarfactura_1_svc(char *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	/*
	 * insert server code here
	 */

	return &result;
}

proxNodoHamburguesa *
listarhamburguesassistema_1_svc(void *argp, struct svc_req *rqstp)
{
	static proxNodoHamburguesa  result;

	/*
	 * insert server code here
	 */

	return &result;
}
